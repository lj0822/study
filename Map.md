# 一、HashMap 面试题

* HashMap的内部结构是什么
  
  * 底层使用哈希表(数组+链表)，当链表过长就会将链表转换成红黑树
  
* 讲一下put方法的过程？
  * 对key求哈希，再计算下标
  * 如果没有碰撞，直接放入桶中
  * 如果链表长度超过阈值(8)，就把链表转换成红黑树
  * 如果节点已经存在就替换旧值
  * 如果达到了扩容条件就 进行resize
  
* Map中的hash函数怎么实现的
  * hash值高低16 位取异或
  * (n-1) & hash 得下标

* HashMap的扩容原理是什么
  * 将数组扩容成原来两倍，再对每个节点进行hash值和位置的重新计算
  * 1.7 和 1.8 的做法不一样
    * 1.7  对每个角标重新再算一次
    * 1.8 将新的hash值和 老数组大小进行&操作，判断是否需要移动
  
* 多线程情况下map会出现什么问题

* 为什么数组长度必须是2的N次幂




#  二、万丈高楼->从数据结构起

* 什么是哈希

翻译成  “散列” ，就是把任意长度的输入，通过散列算法，变成固定长度的输出，该输出就是散列值，这个映射函数叫做散列函数，存放记录的数组叫做散列表

* Map 就是哈希表  数组+ 链表

思考：如何实现一个数组+链表  

链表   []  链表nArr 

```
Node<K,V>[] table;  map 中对于hash表的定义
threshold ： 扩容条件 阈值  12 
map 的初始化容量是 16  
DEFAULT_LOAD_FACTOR： 加载因子 ，扩容因子  0.75
1.7
1.8 
```



Map中表现形式

   Node<K,V>[] table;











#  三、源码阅读+Map的哈希冲突分析



```
map中的哈希算法
目的： 尽可能的通过这个算法来避免hash冲突

( n -1 ）  &   (h = key.hashCode()) ^ (h >>> 16) = index 吗

 
式子1 ：    (n - 1)         数组长度- 1
式子2 ：    (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)


 固定值  &  式子2   =  尽可能不同的结果  =》 式子2 得尽可能的不同
 
key.hashCode() ： 是一个32 位 长度的hashcode

 


本来的哈希code      01000111  01010101  10000000  01001010      低16 位
向右的移动16        00000000  00000000  01000111  01010101    ^ 高16 位
              
--------------------------------------------------------------
									 得到的就是      index
									 
									 
		假设： 		 01000111  01010101  10000000  01000110	
                 							            01111 &    
             ----------------------------------------------------
                                                        
                                                      得到结果一定是 个偶数
                                                      得到的结果就有可能是个偶数 也有可能是个奇数
                                                      
& ： 是同一 得1  ，不同得 0  

									 
									 

问题：
   1.为什么不直接拿着 32 位的hashCode 和 固定值进行计算，而要通过   ^ (h >>> 16)  再计算呢
   			 会了让尽可能多的位数都参与到运算，因为参与运算位数越多，得到重复的可能性就越小
   2.为什么要采用^
   			原因是 通过^  在相同情况下，可以让0和1 ，尽量的平均
   			
  

式子1 ：( n -1 ） 
但是 式子1 有三点目的
    1.为了能够让最后得到的index 值能够落在数组上   0 -15   不就恰好是 数组上的角标吗？
    
    2.为了能够保证得到的index 既有可能是个奇数 也有可能是个偶数
    		 数组长度 必须是2的N 次幂 -> 一定是一个偶数 ->  16 32 64  偶数 他的末尾位 
    为0 ，偶数-1 一定是一个奇数  ，而奇数 他的末尾位  就一定是一个  1 
    		 
    3.充分的运用费了 老大劲算出来的hashCode 
	  
   
 如果面试官问你 哥们，
      map中是如何去避免hash冲突的 ：  首先拿着key 去求出来32位长度的hashCode ，对hashCode 进行高低16 位的异或，和数组的长度-1 进行  &   
      map中是如何去解决hash冲突 :链式地址法
 

Hash算法解决冲突的方法一般有以下几种常用的解决方法 
1， 开放定址法： 
所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 
公式为：fi(key) = (f(key)+di) MOD m (di=1,2,3,……,m-1) 
※ 用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者 
碰到一个开放的地址（即该地址单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到开放的地址则表明表 
中无待查的关键字，即查找失败。 
比如说，我们的关键字集合为{12,67,56,16,25,37,22,29,15,47,48,34},表长为12。 我们用散列函数f(key) = key mod l2 
当计算前S个数{12,67,56,16,25}时，都是没有冲突的散列地址，直接存入： 

这里写图片描述 
计算key = 37时，发现f(37) = 1，此时就与25所在的位置冲突。 
于是我们应用上面的公式f(37) = (f(37)+1) mod 12 = 2。于是将37存入下标为2的位置： 
这里写图片描述

2， 再哈希法： 
再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数
计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。

3， 链地址法： 
链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向 
链表连接起来，如： 
键值对k2, v2与键值对k1, v1通过计算后的索引值都为2，这时及产生冲突，但是可以通道next指针将k2, k1所在的节点连接起来，这样就解决了哈希的冲突问题 
这里写图片描述
4， 建立公共溢出区： 
这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表
	
 
  
 		
 
 		   
 		   
 		   

 
    
 

需求：让两者尽可能的不同-> 参与到运算位数 越多，其实 他产生 重复的可能性就越小


User  age leg foot 

User1   17 3 4 
User2   16 4 6 
杠精： 两个加起来不一样，3 个加起来反而一样的数据


readDifferent1(user1  or  user2){
             17  +  3 = 20 
   return  user.age + user.leg 
              16 +  4 = 20
             

}

readDifferent2(user1  or  user2){
    
   		   17 + 3 + 4 = 24 
   return  user.age + user.leg + user.foot
           16 + 4 + 6 = 26

}



```

# 四、Map 之扩容分析

## 一、啥是扩容，现象是什么

当 map中的元素超过了阈值时，此时就需要进行扩容，拿着节点上的元素和 hash再次进行计算得到一个新的坐标

每次都扩容成原来的2 倍

位置说明 ： 3 % 2 =  1     7 % 2 = 1   5 % 2 = 1

![image-20200316105347563](.\1.png)

同样存放的元素，在发生扩容后，就会改变其位置

位置说明：

5 % 4=  1

7 % 4 = 3

3 % 4 = 3



![image-20200316112959029](.\2.png)

JDK1.7 的做法遍历数组，找到每一个节点，取其链表，再去重新计算其中的每一个数据，而jdk1.8的做法就显的更加的巧妙了



## 二、jdk1.7的扩容方法详解

```java
void transfer(Entry[] newTable) {
    //持有原来的数组
    Entry[] src = table;
    // 拿到新的数组长度，原来是16 ，现在是32 
    int newCapacity = newTable.length;
    // 遍历原来的数组，取到每一个节点，外层循环
    for (int j = 0; j < src.length; j++) {
        //取到每一个节点
        Entry<K,V> e = src[j];
        if (e != null) {
            src[j] = null;
            // 内层循环，遍历该节点上的每一个元素，进行再hash
            do {
                Entry<K,V> next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}
```







## 三、map1.8扩容

map 1.8 扩容比较巧妙

```java
resize（）  -> 1.初始化  2. 扩容
    
for (int j = 0; j < oldCap; ++j) {
    Node<K,V> e;
    if ((e = oldTab[j]) != null) {
        oldTab[j] = null;
        if (e.next == null)
            newTab[e.hash & (newCap - 1)] = e;
        else if (e instanceof TreeNode)
            ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
        else { // preserve order
            Node<K,V> loHead = null, loTail = null;
            Node<K,V> hiHead = null, hiTail = null;
            Node<K,V> next;
            do {
                next = e.next;
                //   if(0)
                //   if(!0)
                if ((e.hash & oldCap) == 0) {
                    if (loTail == null)
                        loHead = e;
                    else
                        loTail.next = e;
                    loTail = e;
                }
                else {
                    if (hiTail == null)
                        hiHead = e;
                    else
                        hiTail.next = e;
                    hiTail = e;
                }
            } while ((e = next) != null);
            if (loTail != null) {
                loTail.next = null;
                newTab[j] = loHead;
            }
            if (hiTail != null) {
                hiTail.next = null;
                newTab[j + oldCap] = hiHead;
            }
        }
    }
}
 ----------------------------------------------------
 1.8 的扩容做法，是遍历数组上的链表数据， 并不是每个人都重新算一遍 -> 
      只是去拿着这个当前遍历到这个值去 & oldCap -> 0  或者是  !0   -> 去挪动元素
      如果是 0 ， 不挪动，就放在原来位置
      如果非 0 ， 就挪动， 挪动的位数是原来位置 + oldCap

 		    01000111  01010101 10000000   01001010 
                                             10000
 		 &                                   01111              
     										011111   
     --------------------------------------------------
                                            011010  如果oldCap 这一位对上去的hash 如果是 1 ，
     此时 结果才会变 啊
                                            原来这个节点应该落在哪儿
                                            新算出来的这个数据  和原来数据如果有变化的话，其实你只需要看谁就够  
     
     
     
                                            
                                             10000  现在的操作
         ----------------------------------------------
                               
                

```

